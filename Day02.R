library(DBI)
library(duckdb)

con <- dbConnect(duckdb())

query_1 <- "
CREATE TABLE IF NOT EXISTS AOC_2024_DAY_2_LEVELS AS
SELECT
  *
FROM
  read_csv ('data/2024_DAY_2.csv');

CREATE TABLE IF NOT EXISTS AOC_2024_DAY_2_METRICS AS (
  WITH
    STEPS AS (
      SELECT
        *,
        LEVEL_1 - LEVEL_2 as STEP1,
        LEVEL_2 - LEVEL_3 as STEP2,
        LEVEL_3 - LEVEL_4 as STEP3,
        LEVEL_4 - LEVEL_5 as STEP4,
        LEVEL_5 - LEVEL_6 as STEP5,
        LEVEL_6 - LEVEL_7 as STEP6,
        LEVEL_7 - LEVEL_8 as STEP7
      FROM
        AOC_2024_DAY_2_LEVELS
    ),
    METRICS AS (
      SELECT
        *,
        LEAST (STEP1, STEP2, STEP3, STEP4, STEP5, STEP6, STEP7) as MIN_STEP,
        GREATEST (STEP1, STEP2, STEP3, STEP4, STEP5, STEP6, STEP7) as MAX_STEP,
        CASE
          WHEN STEP1 = 0
          OR STEP2 = 0
          OR STEP3 = 0
          OR STEP4 = 0
          OR STEP5 = 0
          OR STEP6 = 0
          OR STEP7 = 0 THEN 1
          ELSE 0
        END as FLAT_STEP,
      FROM
        STEPS
    )
  SELECT
    *
  FROM
    METRICS
);

SELECT
  COUNT(*) as SAFE_REPORTS
FROM
  AOC_2024_DAY_2_METRICS
WHERE
  FLAT_STEP <> 1
  AND ABS(MIN_STEP) <= 3
  AND ABS(MAX_STEP) <= 3
  AND SIGN(MIN_STEP) = SIGN(MAX_STEP);
"

DAY_2_RESULT_1 <- dbGetQuery(conn = con, statement = query_1)

query_2 <- "
WITH
  UNSAFE_REPORTS AS (
    SELECT
      *
    FROM
      AOC_2024_DAY_2_METRICS
    WHERE
      NOT (
        FLAT_STEP <> 1
        AND ABS(MIN_STEP) <= 3
        AND ABS(MAX_STEP) <= 3
        AND SIGN (MIN_STEP) = SIGN (MAX_STEP)
      )
  ),
  STEPS AS (
    SELECT
      row_number() OVER () AS REPORT_NUMBER,
      MIN_STEP,
      MAX_STEP,
      FLAT_STEP,
      STEP1,
      STEP2,
      STEP3,
      STEP4,
      STEP5,
      STEP6,
      STEP7
    FROM
      UNSAFE_REPORTS
  ),
  UNPIVOT_STEPS AS (
    UNPIVOT STEPS ON STEP1,
    STEP2,
    STEP3,
    STEP4,
    STEP5,
    STEP6,
    STEP7 INTO NAME STEP_NAME VALUE STEP_VALUE
  ),
  PRE_GROUP_SIGN AS (
    SELECT
      *,
      SIGN (STEP_VALUE) AS STEP_SIGN,
      CASE
        WHEN ABS(STEP_VALUE) > 3 THEN 1
        ELSE 0
      END AS STEP_SIZE_PROBLEM,
      CASE
        WHEN STEP_VALUE = 0 THEN 1
        ELSE 0
      END AS STEP_SIZE_ZERO
    FROM
      UNPIVOT_STEPS
  ),
  GROUP_SIGN_COUNT AS (
    SELECT
      REPORT_NUMBER,
      STEP_SIGN,
      COUNT(*) AS SIGN_COUNT
    FROM
      PRE_GROUP_SIGN
    WHERE
      STEP_SIGN <> 0
    GROUP BY
      REPORT_NUMBER,
      STEP_SIGN
  ),
  MIN_GROUP_SIGN_COUNT AS (
    SELECT
      REPORT_NUMBER,
      MIN(SIGN_COUNT) AS MIN_SIGN_COUNT
    FROM
      GROUP_SIGN_COUNT
    GROUP BY
      REPORT_NUMBER
  ),
  PROBLEM_STEPS AS (
    SELECT
      PGS.*,
      GS.SIGN_COUNT,
      MGSC.MIN_SIGN_COUNT,
      IF (
        MGSC.MIN_SIGN_COUNT = GS.SIGN_COUNT,
        IF (
          SIGN (MIN_STEP) = SIGN (MAX_STEP),
          0,
          IF (MAX_STEP = 0, 0, IF (MIN_STEP = 0, 0, 1))
        ),
        0
      ) AS STEP_SIGN_PROBLEM
    FROM
      PRE_GROUP_SIGN PGS
      LEFT JOIN GROUP_SIGN_COUNT GS ON GS.REPORT_NUMBER = PGS.REPORT_NUMBER
      AND GS.STEP_SIGN = PGS.STEP_SIGN
      LEFT JOIN MIN_GROUP_SIGN_COUNT MGSC ON MGSC.REPORT_NUMBER = PGS.REPORT_NUMBER
      AND MGSC.MIN_SIGN_COUNT = GS.SIGN_COUNT
  ),
  PROBLEM_REPORTS AS (
    SELECT
      REPORT_NUMBER,
      GREATEST (
        STEP_SIZE_PROBLEM,
        STEP_SIZE_ZERO,
        STEP_SIGN_PROBLEM
      ) AS STEP_PROBLEM_ALL
    FROM
      PROBLEM_STEPS
  ),
  ONE_PROBLEM AS (
    SELECT
      REPORT_NUMBER,
      SUM(STEP_PROBLEM_ALL) AS PROBLEM_PER_REPORT
    FROM
      PROBLEM_REPORTS
    GROUP BY
      REPORT_NUMBER
    HAVING
      SUM(STEP_PROBLEM_ALL) = 1
  )
SELECT
  COUNT(*) AS ADDITIONAL_SAFE_REPORTS
FROM
  ONE_PROBLEM


"
DAY_2_RESULT_2 <- dbGetQuery(conn = con, statement = query_2)

cat(DAY_2_RESULT_1$SAFE_REPORTS + DAY_2_RESULT_2$ADDITIONAL_SAFE_REPORTS)
