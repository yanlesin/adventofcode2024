library(DBI)
library(duckdb)

con <- dbConnect(duckdb())

query_1 <- "
CREATE TABLE IF NOT EXISTS AOC_2024_DAY_2_LEVELS AS
SELECT
  *
FROM
  read_csv ('data/2024_DAY_2.csv');

CREATE TABLE IF NOT EXISTS AOC_2024_DAY_2_METRICS AS (
  WITH
    STEPS AS (
      SELECT
        *,
        LEVEL_1 - LEVEL_2 as STEP1,
        LEVEL_2 - LEVEL_3 as STEP2,
        LEVEL_3 - LEVEL_4 as STEP3,
        LEVEL_4 - LEVEL_5 as STEP4,
        LEVEL_5 - LEVEL_6 as STEP5,
        LEVEL_6 - LEVEL_7 as STEP6,
        LEVEL_7 - LEVEL_8 as STEP7
      FROM
        AOC_2024_DAY_2_LEVELS
    ),
    METRICS AS (
      SELECT
        *,
        LEAST (STEP1, STEP2, STEP3, STEP4, STEP5, STEP6, STEP7) as MIN_STEP,
        GREATEST (STEP1, STEP2, STEP3, STEP4, STEP5, STEP6, STEP7) as MAX_STEP,
        CASE
          WHEN STEP1 = 0
          OR STEP2 = 0
          OR STEP3 = 0
          OR STEP4 = 0
          OR STEP5 = 0
          OR STEP6 = 0
          OR STEP7 = 0 THEN 1
          ELSE 0
        END as FLAT_STEP,
      FROM
        STEPS
    )
  SELECT
    *
  FROM
    METRICS
);

SELECT
  COUNT(*) as SAFE_REPORTS
FROM
  AOC_2024_DAY_2_METRICS
WHERE
  FLAT_STEP <> 1
  AND ABS(MIN_STEP) <= 3
  AND ABS(MAX_STEP) <= 3
  AND SIGN (MIN_STEP) = SIGN (MAX_STEP);
"

DAY_2_RESULT_1 <- dbGetQuery(conn = con, statement = query_1)

query_2 <- "
WITH UNSAFE_REPORTS AS (SELECT
  *
FROM
  AOC_2024_DAY_2_METRICS
WHERE
  NOT (FLAT_STEP <> 1
  AND ABS(MIN_STEP) <= 3
  AND ABS(MAX_STEP) <= 3
  AND SIGN (MIN_STEP) = SIGN (MAX_STEP))),

STEP_STATUS AS (SELECT 
  *,
  CASE WHEN STEP1 = 0 OR ABS(STEP1) > 3 THEN 1 ELSE 0 END AS STEP1_STATUS,
  CASE WHEN STEP2 = 0 OR ABS(STEP2) > 3 OR SIGN(STEP2) <> SIGN(STEP1) THEN 1 ELSE 0 END as STEP2_STATUS,
  CASE WHEN STEP3 = 0 OR ABS(STEP3) > 3 OR SIGN(STEP3) <> SIGN(STEP2) THEN 1 ELSE 0 END as STEP3_STATUS,
  CASE WHEN STEP4 = 0 OR ABS(STEP4) > 3 OR SIGN(STEP4) <> SIGN(STEP3) THEN 1 ELSE 0 END as STEP4_STATUS,
  CASE WHEN STEP5 = 0 OR ABS(STEP5) > 3 OR SIGN(STEP5) <> SIGN(STEP4) THEN 1 ELSE 0 END as STEP5_STATUS,
  CASE WHEN STEP6 = 0 OR ABS(STEP6) > 3 OR SIGN(STEP6) <> SIGN(STEP5) THEN 1 ELSE 0 END as STEP6_STATUS,
  CASE WHEN STEP7 = 0 OR ABS(STEP7) > 3 OR SIGN(STEP7) <> SIGN(STEP6) THEN 1 ELSE 0 END as STEP7_STATUS,
FROM UNSAFE_REPORTS),

STEP_STATUS_ALL AS (SELECT *, STEP1_STATUS+STEP2_STATUS+STEP3_STATUS+STEP4_STATUS+STEP5_STATUS+STEP6_STATUS+STEP7_STATUS AS STEP_STATUS FROM STEP_STATUS),

STEP_STATUS_WITH_HOPE AS (SELECT row_number() OVER() AS ROW_NUMBER, SIGN(STEP1) AS SIGN1, SIGN(STEP2) AS SIGN2, SIGN(STEP3) AS SIGN3, SIGN(STEP4) AS SIGN4, SIGN(STEP5) AS SIGN5, SIGN(STEP6) AS SIGN6, SIGN(STEP7) AS SIGN7 FROM STEP_STATUS_ALL WHERE STEP_STATUS <= 1),

UNPIVOT_STEPS AS (UNPIVOT STEP_STATUS_WITH_HOPE
ON SIGN1,SIGN2,SIGN3,SIGN4,SIGN5,SIGN6,SIGN7
INTO
NAME STEP
VALUE SIGN),

SIGN_COUNT AS (SELECT ROW_NUMBER, COUNT(*) AS SAME_SIGN_COUNT FROM UNPIVOT_STEPS
GROUP BY ROW_NUMBER, SIGN),

SIGN_COUNT_WITH_HOPE AS (SELECT ROW_NUMBER, COUNT(*) AS SIGN_COUNT FROM SIGN_COUNT
GROUP BY ROW_NUMBER
HAVING COUNT(*) <3)

SELECT * FROM SIGN_COUNT SC
JOIN SIGN_COUNT_WITH_HOPE SCH ON SC.ROW_NUMBER = SCH.ROW_NUMBER
WHERE SCH.SIGN_COUNT = 1
OR (SCH.SIGN_COUNT = 2 and SC.SAME_SIGN_COUNT = 1)
"
DAY_2_RESULT_2 <- dbGetQuery(conn = con, statement = query_2)
openxlsx2::write_xlsx(DAY_2_RESULT_2, '1.xlsx')
cat(DAY_2_RESULT_1$SAFE_REPORTS + DAY_2_RESULT_2$ADDITIONAL_SAFE_REPORTS)
